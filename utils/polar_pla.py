from time import time
import matplotlib.pyplot as plt
import numpy as np
import math
from numpy.lib.function_base import average
from matplotlib.lines import Line2D
from matplotlib.pylab import gca, figure, plot, subplot, title, xlabel, ylabel, xlim,show
import random
#import utils.segment as segment
#import utils.fit as fit

def median_filter(time_series, filter_size):
    '''
    This method applies median filtering to a time series to remove noise
    '''
    result = []

    for i in range(len(time_series)):
        if((i < (filter_size-1)/2) or i>(len(time_series))-(filter_size-1)/2 - 1):
            result.append(time_series[i])

        else:
            temp = []
            for pos in range(filter_size):
                temp.append(time_series[i - filter_size//2 + pos])
            
            temp.sort()
            med = temp[len(temp)//2]
            result.append(med)
    #plt.plot(result)
    #plt.show()
    return result

def simple_moving_average(time_series, window_size):
    moving_average = []
    for i in range(len(time_series)):
        if (i<window_size):
            moving_average.append(sum(time_series[:i+1])/(i+1))
        else: 
            moving_average.append(sum(time_series[i+1-window_size:i+1])/window_size)
    
    return moving_average

def sliding_window_pla(time_series, max_error):

    # do minmax normalization on the time series 
    for i in range(len(time_series)):
        time_series[i] = (time_series[i] - min(time_series))/(max(time_series)-min(time_series))
    
    # scale the minmax normalized by 100 so that there is a sufficiently large angle between trends
    time_series = [x*5000 for x in time_series]
    
    x = sliding_window(time_series, max_error)
    
    
    output = []
    trendX, trendY = [], []
    for trend in x:#.transform(time_series):
        # first we need the angle of inclination. We will normalize this to a value from -1 to 1 (-90 degrees to 90 degrees)
        # each trend has the structure [startX, startY, endX, endY], however this doesn't lend itself well to ML since 
        # incorrect x prediction values can go backwards.
        startX, startY, endX, endY = trend[0], trend[1], trend[2], trend[3]
        
        trendX.append(startX) # this is to plot the trends
        trendX.append(endX)
        trendY.append(startY)
        trendY.append(endY)
        
        angle = math.degrees(math.atan((endY - startY)/(endX - startX)))
        # now we need to normalize the angle to a value from -1 to 1
        angle /= 90
        
        # now we need to calculate the length of the trend
        length = trend[2]-trend[0]#np.sqrt((endX - startX)**2 + (endY - startY)**2)
        output.append(angle)
        output.append(length)

    max_length = max(output)
    w = open('trends.csv','w')
    for i in range(0,len(output),2):
        w.write(str(output[i])+","+str(output[i+1]/max_length)+"\n")
    for val in range(1,len(output),2):
        output[val] = output[val]/max_length
    plt.plot(time_series, color='gray')
    for x in range(0,len(trendX),2):
        
        tX = [trendX[x],trendX[x+1]]
        tY = [trendY[x],trendY[x+1]]
        
        plt.plot(tX, tY,color='red')
    plt.show()
    return output, max_length

def display_trends(trends, startY):
    # this function will reconstruct a graph using the trends generated by the bottom_up_pla function
    # it will also display the graph
    X = [0]
    Y = [startY]
    for i in range(0,len(trends),2):
        #print(trends[i])
        X.append(X[int(i/2)]+(trends[i+1])*np.cos(np.deg2rad(trends[i]*90)))
        #print(X[i-1]+(trends[i][1]*10)/np.cos(np.deg2rad(trends[i][0])))
        Y.append(Y[int(i/2)]+(trends[i+1])*np.sin(np.deg2rad(trends[i]*90)))
        #print(Y[i-1]+(trends[i][1])*np.sin(np.deg2rad(trends[i][0])))
    plt.plot(X,Y)
    #plt.show()

def bottom_up(time_series, max_error, minimum_trend_length):

    # okay whoever wrote that PLS library your code is booboo
    # let me show you how it's done
    trends = []
    for i in range(len(time_series)-1):
        # make lots of little trends
        trends.append((time_series[i], time_series[i+1]))
    
    max_error = 100
    windowsize = 3 # think of this as the number of elements in our window
    i = 0
    m = math.mean(time_series[i:i+windowsize])
    window_var = (time_series[0]-m)**2
    window_var += (time_series[1]-m)**2
    window_var += (time_series[2]-m)**2
    window_var /= 2

    # now we have the variance of a basic window
    # now keep growing the window until we exceed the max error
    while(window_var < max_error):
        # ref: https://math.stackexchange.com/questions/102978/incremental-computation-of-standard-deviation
        # now we need to grow the window and adjust the variance using this handy equation
        windowsize += 1
        window_var = (windowsize-2)/(windowsize-1) * window_var + (1/(windowsize))*(time_series[windowsize-1]-m)**2
        m = (m*(windowsize-1)+time_series[windowsize])/windowsize


def sliding_window(time_series, max_error):
    anchor = 0
    trends = []
    window_size = 2
    # initial calculation 
    data = time_series[0:window_size]
    E_x = (window_size+1)/2
    E_y = average(data)
    E_y2= average(np.square(data))
    yes = []
    for fish in range(len(data)):
        yes.append(data[fish]*(fish+1))
    E_xy = (sum(yes))/window_size
    E_x2 = average(np.square(range(1,window_size+1)))
    m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
    b = E_y-m*E_x
    loss = E_y2 - 2 * (m * E_xy + b * E_y) + m**2 * E_x2 + 2 * m * b * E_x + b**2
    #print(f"Initial calculation: m={m}, b={b}")
    # now expand the window size
    while anchor + window_size + 1 < len(time_series):
        while loss*window_size < max_error and anchor + window_size + 1 < len(time_series):
            window_size+=1
            N = window_size-1
            new_x = window_size
            new_y = time_series[anchor+window_size-1]
            E_x = E_x*N/(N+1) + new_x*1/(N+1)
            E_y = E_y*N/(N+1) + new_y*1/(N+1)
            E_xy = E_xy*N/(N+1) + new_x*new_y/(N+1)
            E_x2 = E_x2*N/(N+1) + new_x*new_x/(N+1)
            E_y2 = E_y2*N/(N+1) + new_y*new_y/(N+1)
            t_m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
            t_b = E_y-t_m*E_x
            loss = E_y2 - 2 * (t_m * E_xy + t_b * E_y) + t_m**2 * E_x2 + 2 * t_m * t_b * E_x + t_b**2
            if loss*window_size < max_error:
                m = t_m
                b = t_b
        #print("trend added m:"+str(m)+" b:"+str(b)+" window size = "+str(window_size))
        trends.append([anchor, b+m, anchor+window_size-2, b+m*(window_size-1)])
        anchor += window_size-2
        window_size = 2
        if anchor + window_size + 1 < len(time_series):
            data = time_series[anchor:anchor+window_size]
            E_x = (window_size+1)/2
            E_y = average(data)
            E_y2= average(np.square(data))
            yes = []
            for fish in range(len(data)):
                yes.append(data[fish]*(fish+1))
            E_xy = (sum(yes))/window_size
            E_x2 = average(np.square(range(1,window_size+1)))
            m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
            b = E_y-m*E_x
            loss = E_y2 - 2 * (m * E_xy + b * E_y) + m**2 * E_x2 + 2 * m * b * E_x + b**2

    #trends.append([anchor, b, anchor+window_size, (time_series[anchor]+b+(window_size)*m)])
    return trends

values = [0,0,0,0,0,0,0,0] # E_x, E_y, E_xy, E_x2, E_y2, m, b, loss
trends = []
current_trend_index = -1
def sliding_window_online(point, max_error):
    # A trend looks like this: [start x, start y, end x, end y]
    global trends
    global values
    global current_trend_index
    
    if len(trends) == 0:  # after first run we have one point, add it
        trends.append([0, point, 0, point])
        current_trend_index = 0
        #values = [0.5, point[1], point[0]*point[1], point[0]**2, point[1]**2, 0, 0, 0]

    elif trends[-1][0] == trends[-1][2]: # in the case our current latest trend has only one point, make it a line with the next point
        point = [trends[-1][2]+1, point]
        trends[-1] = [trends[-1][0],trends[-1][1], point[0], point[1]]
        values[0] = values[0] + 0.5 # E_x
        values[1] = (trends[-1][1] + point[1])/2 # E_y
        values[2] = (trends[-1][1]*trends[-1][0] + point[1]*point[0])/2 # E_xy
        values[3] = (trends[-1][0]**2+point[0]**2)/2 # E_x2
        values[4] = (trends[-1][1]**2+point[1]**2)/2 # E_y2
        values[5] = (point[1]-trends[-1][1]) # m
        values[6] = (point[1]-values[5]*point[0]) # b
        values[7] = 0 # loss
            #print trends with each value rounded to 2 decimal places


    else: # otherwise we're in the middle of a normal trend
        current_trend = trends[-1]
        window_size = current_trend[2] - current_trend[0] + 2
        N = window_size-1
        new_x = current_trend[2]+1
        new_y = point
        E_x = values[0]*N/(N+1) + new_x*1/(N+1)
        E_y = values[1]*N/(N+1) + new_y*1/(N+1)
        E_xy = values[2]*N/(N+1) + new_x*new_y/(N+1)
        E_x2 = values[3]*N/(N+1) + new_x*new_x/(N+1)
        E_y2 = values[4]*N/(N+1) + new_y*new_y/(N+1)
        t_m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
        t_b = E_y-t_m*E_x
        loss = E_y2 - 2 * (t_m * E_xy + t_b * E_y) + t_m**2 * E_x2 + 2 * t_m * t_b * E_x + t_b**2
        if loss*window_size < max_error:
            m = t_m
            b = t_b
            values = [E_x, E_y, E_xy, E_x2, E_y2, m, b, loss]
            trends[-1] = [current_trend[0], b+m*current_trend[0], current_trend[0]+window_size-1, b+m*(current_trend[2]+1)]

        else:
            # trend is over finalise previous trend and add the new point to a new trend
            b = values[6]
            m = values[5]
            trends.append([trends[-1][2],trends[-1][3], new_x, new_y])

            point = [trends[-1][2], point]
            values[0] =  (trends[-1][0]+trends[-1][2])/2 # E_x
            values[1] = (trends[-1][1] + point[1])/2 # E_y
            values[2] = (trends[-1][1]*trends[-1][0] + point[1]*point[0])/2 # E_xy
            values[3] = (trends[-1][0]**2+point[0]**2)/2 # E_x2
            values[4] = (trends[-1][1]**2+point[1]**2)/2 # E_y2
            values[5] = (point[1]-trends[-1][1]) # m
            values[6] = (point[1]-values[5]*point[0]) # b
            values[7] = 0 # loss
            current_trend_index += 1
            #print(current_trend_index)

        #trends.append([anchor, b, anchor+window_size, (time_series[anchor]+b+(window_size)*m)])
    output = trends
    return output

def draw_plot(data,plot_title):
    plot(range(len(data)),data,alpha=0.8,color='red')
    title(plot_title)
    xlabel("Samples")
    ylabel("Signal")
    xlim((0,len(data)-1))

def draw_segments(segments):
    ax = gca()
    for segment in segments:
        line = Line2D((segment[0],segment[2]),(segment[1],segment[3]))
        ax.add_line(line)

def convert_trend_representation(trends, duration_scale):
    '''
        Takes a list of trends where each trend is in the form [startX, startY, endX, endY]
        Returns a list where each trend is represented as [slope, duration]
    '''
    result = []
    for trend in trends:
        # find the slope in degrees
        slope = math.degrees(math.atan((trend[3]-trend[1])/(trend[2]-trend[0])))
        # now we need to normalize the angle to a value from -1 to 1
        #slope /= 90
        
        duration = trend[2]-trend[0]
        #duration /= duration_scale
        
        #result.append([slope,duration])
        result.append([slope,duration])
    return result

def preprocess(file_name, filter_size, pls_max_error, seq_length, component):
    '''
        Performs all data preprocessing steps and returns a processed trend series
    '''
    global trends
    global current_trend_index
    global values
    
    # read in the time series
    f = open(file_name, 'r')
    time_series = []
    for line in f:
        time_series.append(float(line))
    
    if filter_size > 0:
        #time_series = median_filter(time_series, filter_size)
        time_series = simple_moving_average(time_series, filter_size)
    
    time_series_normalized = []
    # do minmax normalization on the time series 
    for i in range(len(time_series)):
        time_series_normalized.append((time_series[i] - min(time_series))/(max(time_series)-min(time_series)))
    time_series_normalized = simple_moving_average(time_series_normalized, 5)
    # scale the minmax normalized by 100 so that there is a sufficiently large angle between trends
    #time_series = [x*5000 for x in time_series]

    finished_pla = []
    
    for point in time_series:
        sliding_window_online(point, pls_max_error)
    
    finished_pla = trends
    print("TOTAL TRENDS: " + str(len(finished_pla)))
    values = [0,0,0,0,0,0,0,0] # E_x, E_y, E_xy, E_x2, E_y2, m, b, loss
    trends = []
    current_trend_index = -1

    inputs = []
    outputs = []
    index = 0
    
    yuh = []
    for x in range(seq_length):
        sliding_window_online(time_series[index], pls_max_error)
        index += 1
    
    while(len(trends) < seq_length):
        yuh = sliding_window_online(time_series[index], pls_max_error)
        index += 1

    #for x in range(len(time_series)-index-5000):
    max_len = 0
    for t in finished_pla:
        if (t[2]-t[0]) > max_len:
            max_len = t[2]-t[0]
    print("Longest trend line length: " + str(max_len))

    yuh = sliding_window_online(time_series[index], pls_max_error)
    index += 1
    # forming of input output pairs
    while current_trend_index < len(finished_pla)-1:
        max_len = 1
        temp = convert_trend_representation(trends[current_trend_index-seq_length+1:current_trend_index+1], max_len)
        
        #for p in time_series_normalized[index-7:index+1]:
        #    temp.append([p, 0])
        
        #[[s1, d1], [s2, d2], [s3, d3], [s4, d4], [s5, d5], [s6, d6], [s7, d7], [s8, d8]]
        
        inputs.append(temp)
        #temp = trends[current_trend_index-seq_length+1:current_trend_index]
        #temp.append(finished)
        #inputs.append(convert_trend_representation(, max_len))

        current_trend = finished_pla[current_trend_index]
        next_trend = finished_pla[current_trend_index+1]

        current_trend_duration = current_trend[2]-current_trend[0]
        online_trend_duration = trends[-1][2]-trends[-1][0]
        
        remaining_duration = current_trend_duration - online_trend_duration


        startX, startY, endX, endY = next_trend[0], next_trend[1], next_trend[2], next_trend[3]
        next_trend_angle = math.degrees(math.atan((endY-startY)/(endX-startX)))#/90

        #outputs.append([next_trend_angle/90, remaining_duration/max_len])
        if component == 0:
            #outputs.append([next_trend_angle])
            outputs.append([next_trend_angle])
        elif component == 1:
            outputs.append([remaining_duration/max_len])
        elif component == 2:
            outputs.append([next_trend_angle, remaining_duration/max_len])
            
        yuh = sliding_window_online(time_series[index], pls_max_error)
        index += 1
    
    #print("FINAL TRENDS", convert_trend_representation(trends, 1))
    #print()
    #print("INPUTS ", inputs)
    #print()
    #print("OUTPUTS ", outputs)
    plt.plot(time_series, color='orange', alpha=1, linewidth=8)
    for t in finished_pla:
        plt.plot([t[0],t[2]],[t[1],t[3]], color='magenta', linewidth=3)
    
    for t in yuh:
        plt.plot([t[0],t[2]],[t[1],t[3]], color='grey')
    #plot the time series in purple
    #plt.ion()
    plt.show()

    plt.show()

    return inputs, outputs

def preprocess_from_pickle(file_name, seq_length, component):
    '''
        Performs all data preprocessing steps and returns a processed trend series
    '''
    import pickle

    with open(file_name, 'rb') as f:
        data = pickle.load(f)

    trends = data.iloc[:,0:2].values
    inputs = []
    outputs = []
    for i in range(seq_length, len(trends)-1):
        inputs.append(trends[i-seq_length+1:i+1].tolist())
        
        if component == 0:
            outputs.append([trends[i+1].tolist()[0]])
        elif component == 1:
            outputs.append([trends[i+1].tolist()[1]])
        elif component == 2:
            outputs.append(trends[i+1].tolist())
    return inputs, outputs
    
    
    
    
    return 1#inputs, outputs

if __name__ == "__main__":
    f = open('DataSets/CTtemp.csv')
    data = f.readlines()[0:1000]
    f.close()
    ts = []
    for line in data:
        ts.append(float(line))
    #plt.plot(ts)
    #ts = median_filter(ts, 5)
    sample = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,15,14,13,12,11,10,9,8,9,10,11,12,13,12,11,10,9,8,7,6,5,4,3,2,1,3,5,7,9,11,13]
    ts = sample
    #trends = sliding_window(ts, 6000)#PiecewiseLinearSegmentation.Sliding(0).transform(ts)#
    #print(trends)
    plt.plot(ts, color='blue',linewidth=3)
    #for t in trends:
    #    plt.plot([t[0],t[2]],[t[1],t[3]], color='orange')
    #plt.show()
    for i in range(18):
        #print(f"\n\n                                                                 Iteration {i+1}:")
        test = sliding_window_online(ts[i], 0)
        #print("trends:",trends)
        #print("values:",values)
        #print(f"\n\n")
    plt.plot(ts, color='blue',linewidth=1)
    for t in test:
        plt.plot([t[0],t[2]],[t[1],t[3]], color='orange')
    for trend in test:
        print([ '%.2f' % elem for elem in trend ])
    plt.show()